<%
/*

Retrieves MDN compat data for a given feature

Parameters

$0 – A query string indicating for which feature to retrieve compat data for.
$1 – A depth setting indicating how deep sub features should be added to the table
(flattened, default: 1 level, meaning any compat data for the given feature,
and compat data for any of its immediate children).
$2 – A boolean setting whether to enable "aggregate mode" (defaults to false).
    Aggregate mode means:
      - Notes aren't displayed, instead an asterisk is shown.
      - Features are linked to MDN pages (and thus aggregate mode tables should only
        be used for features that have MDN pages)

Example calls

  {{compat("webextensions.api.alarms")}}
  {{compat("webextensions.api.alarms.Alarm")}}
  {{compat("webextensions.manifest")}}
  {{compat("webextensions.manifest.applications")}}
  {{compat("css.properties.background-attachment")}}
  {{compat("css.selectors.any-link")}}
  {{compat("css.at-rules.font-face")}}
  {{compat("http.headers.Cache-Control")}}
  {{compat("http.status.404")}}
  {{compat("http.method.CONNECT")}}
  {{compat("api.WebGL2RenderingContext")}}
  {{compat("api.WebGL2RenderingContext.beginQuery")}}
  {{compat("html.elements.input")}}

  {{compat("html.elements.link", 2)}}

  {{compat("webextensions.api.alarms, 3, true")}}

*/

const bcd = require('mdn-browser-compat-data');
var query = $0;
var depth = $1 || 1;
var aggregateMode = $2 || false;
var output = '';

var compatStrings = string.deserialize(template('L10n:CompatTable'));
var localize = mdn.getLocalString;


var s_no_data_found = mdn.localString({
  'en-US': `No compatibility data found. Please contribute data for "${query}" (depth: ${depth}) to the <a href="https://github.com/mdn/browser-compat-data">MDN compatibility data repository</a>.`
});

var s_firefox_android = mdn.localString({
  'en-US': 'Firefox for Android'
});

var s_chrome_android = mdn.localString({
  'en-US': 'Chrome for Android'
});

var s_opera_android = mdn.localString({
  'en-US': 'Opera for Android'
});

var s_desktop = mdn.localString({
  'en-US': 'Desktop'
});

var s_mobile = mdn.localString({
  'en-US': 'Mobile'
});

var s_server = mdn.localString({
  'en-US': 'Server'
});

const browsers = {
  "desktop": {
    chrome: 'Chrome',
    edge: 'Edge',
    firefox: 'Firefox',
    ie: 'Internet Explorer',
    opera: 'Opera',
    safari: 'Safari',
  },
  "mobile": {
    webview_android: 'Android',
    chrome_android: s_chrome_android,
    edge_mobile: 'Edge mobile',
    firefox_android: s_firefox_android,
    ie_mobile: 'IE mobile',
    opera_android: 'Opera Android',
    safari_ios: 'iOS Safari',
  },
  "webextensions": {
    chrome: "Chrome",
    edge: "Edge",
    firefox: "Firefox",
    firefox_android: s_firefox_android,
    opera: "Opera",
  }
};

var notesArray = [];

/*
Write the table header.

`browserPlatformType` is either "mobile", "desktop" or "webextensions"
*/
function writeTableHead(browserPlatformType) {
  let browserNameKeys = Object.keys(browsers[browserPlatformType]);
  let output = '';
  if (browserPlatformType === 'webextensions') {
    output = '<table class="webext-summary-compat-table"><thead><tr><th style="width: 40%"></th>'
    let browserColumnWidth = 60/browserNameKeys.length;
    for (let browserNameKey of browserNameKeys) {
      output += `<th style="width:${browserColumnWidth}%">${browsers[browserPlatformType][browserNameKey]}</th>`;
    }
    output += "<tr></thead>";
  } else {
    output = `<div id="compat-${browserPlatformType}"><table class="compat-table"><thead><tr>`;
    output +=  `<th>${localize(compatStrings, 'feature')}</th>`
    for (let browserNameKey of browserNameKeys) {
      output += `<th>${browsers[browserPlatformType][browserNameKey]}</th>`;
    }
    output += '</tr></thead>';
  }
  return output;
}

/*
Given the value of `version_added` or `version_removed`, this returns
a string to appear in the table cell, like "Yes", "No" or "?"

`versionInfo` is either null, true, false or a string containing a version number
*/
function getVersionString(versionInfo) {
  switch (versionInfo) {
    case null:
      return `<span title="${localize(compatStrings, 'supportsShort_unknown_title')}">
      ${localize(compatStrings, 'supportsShort_unknown')}</span>`;
    break;
    case true:
      return `<span title="${localize(compatStrings, 'supportsShort_yes_title')}">
      ${localize(compatStrings, 'supportsShort_yes')}</span>`;
    break;
    case false:
      return `<span title="${localize(compatStrings, 'supportsLong_no')}">
      ${localize(compatStrings, 'supportsShort_no')}</span>`;
    break;
    default:
      return versionInfo;
  }
}

/*
Given the support information for a browser, this returns
a CSS class to apply to the table cell.

`supportData` is a (or an array of) support_statement(s)
*/
function getSupportClass(supportInfo) {
  let cssClass = 'unknown-support';

  if (Array.isArray(supportInfo)) {
    // the first entry should be the most relevant/recent and will be treated as "the truth"
    checkSupport(supportInfo[0].version_added, supportInfo[0].version_removed);
  } else if (supportInfo) { // there is just one support statement
    checkSupport(supportInfo.version_added, supportInfo.version_removed);
  } else { // this browser has no info, it's unknown
  return 'unknown-support';
}

function checkSupport(added, removed) {
  if (added === null) {
    cssClass = 'unknown-support';
  } else if (added) {
    cssClass = 'full-support';
    if (removed) {
      cssClass = 'no-support';
    }
  } else {
    cssClass = 'no-support';
  }
}

return cssClass;
}

/*
Generate the note for a browser flag or preference
First checks version_added and version_removed to create a string indicating when
a preference setting is present. Then creates a (browser specific) string
for either a preference flag or a compile flag.

`supportData` is a support_statement
`browserId` is a compat_block browser ID
*/
function writeFlagsNote(supportData, browserId) {
  let output = '';

  const firefoxPrefs = 'To change preferences in Firefox, visit about:config.';
  const chromePrefs = 'To change preferences in Chrome, visit chrome://flags.';

  if (typeof(supportData.version_added) === 'string') {
    output = 'From version ' + supportData.version_added;
  }

  if (typeof(supportData.version_removed) === 'string') {
    if (output) {
      output += ' until version '+ supportData.version_removed + ' (exclusive): ';
    } else {
      output = 'Until version ' + supportData.version_removed + ' (exclusive): ';
    }
  } else {
    output += ', ';
  }

  let flagText = `this feature is behind the <code>${supportData.flag.name}</code>`;

  // value_to_set is optional
  let valueToSet = '';
  if (supportData.flag.value_to_set) {
    valueToSet = ` (needs to be set to <code>${supportData.flag.value_to_set}</code>)`;
  }

  if (supportData.flag.type === 'preference') {
    let prefSettings = '';
    switch (browserId) {
      case 'firefox':
      case 'firefox_android':
        prefSettings = firefoxPrefs;
      break;
      case 'chrome':
      case 'chrome_android':
        prefSettings = chromePrefs;
      break;
    }
    output += `${flagText} preference${valueToSet}. ${prefSettings}`;
  }

  if (supportData.flag.type === 'compile_flag') {
    output += `${flagText} compile flag${valueToSet}.`;
  }

  return output;
}


/*
Main function responsible for the contents of a support cell in the table.

`supportData` is a support_statement
`browserId` is a compat_block browser ID
`compatNotes` is collected Compatibility notes

*/
function writeSupportInfo(supportData, browserId, compatNotes) {
  let output = '';

  // browsers are optional in the data, display them as "?" in our table
  if (!supportData) {
    output += getVersionString(null);
  // we have support data, lets go
  } else {
    output += getVersionString(supportData.version_added);

    if (supportData.version_removed) {
      // We don't know when
      if (typeof(supportData.version_removed) === 'boolean' && supportData.version_removed) {
        output += '&nbsp;—?'
      } else { // We know when
        output += '&nbsp;— ' + supportData.version_removed;
      }
    }

    // Add prefix
    if (supportData.prefix) {
      output += `<span title="prefix" class="inlineIndicator prefixBox prefixBoxInline">
      <a title="The name of this feature is prefixed with '${supportData.prefix}' as this
      browser considers it experimental" href="/en-US/docs/Web/Guide/Prefixes">${supportData.prefix}
      </a></span>`;
    }

    // Add alternative name
    if (supportData.alternative_name) {
      output += ` (as <code>${supportData.alternative_name}</code>)`;
    }

    // Add note anchors
    // There are two types of notes (notes, and flag notes).
    // Collect them and order them, before adding them to the cell
    let noteAnchors = [];

    // Generate notes, if any
    if (compatNotes && supportData.notes) {
      if (Array.isArray(supportData.notes)) {
        for (let note of supportData.notes) {
          let noteIndex = compatNotes.indexOf(note);
          noteAnchors.push(`<sup><a href="#compatNote_${noteIndex+1}">${noteIndex+1}</a></sup>`);
        }
      } else {
        let noteIndex = compatNotes.indexOf(supportData.notes);
        noteAnchors.push(`<sup><a href="#compatNote_${noteIndex+1}">${noteIndex+1}</a></sup>`);
      }
    }

    // there is a flag and it needs a note, too
    if (compatNotes && supportData.flag) {
      let flagNote = writeFlagsNote(supportData, browserId);
      let noteIndex = compatNotes.indexOf(flagNote);
      noteAnchors.push(`<sup><a href="#compatNote_${noteIndex+1}">${noteIndex+1}</a></sup>`);
    }
    noteAnchors = noteAnchors.sort();
    if ((supportData.partial_support || noteAnchors.length > 0) && aggregateMode) {
      output += ' *';
    } else {
      output += noteAnchors.join(' ');
    }
  }
  return output;
}

/*
Iterate into all "support" objects, and all browsers under them,
and collect all notes in an array, without duplicates.
*/
function collectCompatNotes() {

  function pushNotes(supportEntry, browserName) {
    // collect notes
    if (supportEntry.hasOwnProperty('notes')) {
      let notes = supportEntry['notes'];
      if (Array.isArray(notes)) {
        for (let note of notes) {
          if (notesArray.indexOf(note) === -1) {
            notesArray.push(note);
          }
        }
      } else {
        if (notesArray.indexOf(notes) === -1) {
          notesArray.push(notes);
        }
      }
    }
    // collect flags
    if (supportEntry.hasOwnProperty('flag')) {
      let flagNote = writeFlagsNote(supportEntry, browserName);
      if (notesArray.indexOf(flagNote) === -1) {
        notesArray.push(flagNote);
      }
    }
  }
  for (let row of features) {
    let support = Object.keys(row).map((k) => row[k])[0].support;
    for (let browserName of Object.keys(support)) {
      if (Array.isArray(support[browserName])) {
        for (let entry of support[browserName]) {
          pushNotes(entry, browserName);
        }
      } else {
        pushNotes(support[browserName], browserName);
      }
    }
  }
  return notesArray;
}

/*
For a single row, write all the cells that contain support data.
(That is, every cell in the row except the first, which contains
an identifier for the row,  like "Basic support".

*/
function writeSupportCells(supportData, compatNotes, browserPlatformType) {
  let output = '';

  for (let browserNameKey of Object.keys(browsers[browserPlatformType])) {
    let support = supportData[browserNameKey];
    let supportInfo = '';
    // if supportData is an array, there are multiple support statements
    if (Array.isArray(support)) {
      for (let entry of support) {
        supportInfo += `<p>${writeSupportInfo(entry, browserNameKey, compatNotes)}</p>`;
      }
    } else if (support) { // there is just one support statement
      supportInfo = writeSupportInfo(support, browserNameKey, compatNotes);
    } else { // this browser has no info, it's unknown
    supportInfo = writeSupportInfo(null);
  }
  output += `<td class="${getSupportClass(supportData[browserNameKey])}">${supportInfo}</td>`;
}
return output;
}

/*
Write compat table
*/
function writeTable(browserPlatformType) {
  let compatNotes = collectCompatNotes();
  let output = writeTableHead(browserPlatformType);
  output += '<tbody>';
  for (let row of features) {
    let feature = Object.keys(row).map((k) => row[k])[0];
    let desc = `<code>${Object.keys(row)[0]}</code>`;
    if (feature.mdn_url) {
      desc = `<a href="${feature.mdn_url}"><code>${Object.keys(row)[0]}</code></a>`;
    }
    if (feature.description) {
      let label = Object.keys(row)[0];
      // Basic support or unnested features need no prefixing
      if (label.indexOf('.') === -1) {
        desc = feature.description;
        // otherwise add a prefix so that we know where this belongs to (e.g. "parse: ISO 8601 format")
      } else {
        desc = `<code>${label.slice(0, label.lastIndexOf('.'))}</code>: ${feature.description}`;
      }
    }
    output += `<tr><td>${desc}</td>`;
    output += `${writeSupportCells(feature.support, compatNotes, browserPlatformType)}</tr>`;
  }
  output += '</tbody></table></div>';
  return output;
}

/*
Write each compat note, with an `id` so it will be linked from the table.
*/
function writeNotes() {
  let output = '';
  let compatNotes = collectCompatNotes();
  for (let note of compatNotes) {
    let noteIndex = compatNotes.indexOf(note);
    output += `<p id=compatNote_${noteIndex+1}>${noteIndex+1}. ${note}</p>`;
  }
  return output;
}

/*
  NEW
  // TODO: can this handle removal of a browser?
*/

const browsersLookup = {
  "webview_android": {
    "name": "Android",
    "platform": "mobile"
  },
  "chrome": {
    "name": "Chrome",
    "platform": "desktop"
  },
  "chrome_android": {
    "name": s_chrome_android,
    "platform": "mobile"
  },
  "edge": {
    "name": "Edge",
    "platform": "desktop"
  },
  "edge_mobile": {
    "name": "Edge Mobile",
    "platform": "mobile"
  },
  "firefox": {
    "name": "Firefox",
    "platform": "desktop"
  },
  "firefox_android": {
    "name": s_firefox_android,
    "platform": "mobile"
  },
  "ie": {
    "name": "IE",
    "platform": "desktop"
  },
  "ie_mobile": {
    "name": "IE mobile",
    "platform": "mobile"
  },
  "nodejs": {
    "name": "Node.js",
    "platform": "server"
  },
  "opera": {
    "name": "Opera",
    "platform": "desktop"
  },
  "opera_android": {
    "name": s_opera_android,
    "platform": "mobile"
  },
  "safari": {
    "name": "Safari",
    "platform": "desktop"
  },
  "safari_ios": {
    "name": "Safari iOS",
    "platform": "mobile"
  },
  "servo": {
    "name": "Servo",
    "platform": "desktop"
  }
};

const platformsLookup = {
  "desktop": {
    "name": s_desktop,
  },
  "mobile": {
    "name": s_mobile,
  },
  "server": {
    "name": s_server,
  }
};

const iconsLookup = {
  "experimental": {
    "name": "Experimental",
    "desc": "Experimental. Expect behavior to change in the future."
  },
  "non-standard": {
    "name": "Non-standard",
    "desc": "Non-standard. Expect poor cross-browser support."
  },
  "obsolete": {
    "name": "Obsolete",
    "desc": "Obsolete. Not for use in new websites."
  }
};

/*
  "prefix": {
    "name": "Prefixed",
    "desc": "Requires the vendor prefix: {{supports.prefix}}.", // TODO
    "legend": "Requires a <a href='https://developer.mozilla.org/docs/Glossary/Vendor_Prefix'>vendor prefix</a>.";
  },
  "altname": {
    "name": "Alternate Name",
    "desc": "Uses the non-standard name: {{alternate_name}}.", // TODO
    "legend": "Uses a non-standard name."
  },
  "disabled": {
    "name": "Disabled",
    "desc": " if(support.requires_config && support.default_config) { The user must change {{default_config}} to {{requires_config}} to enable this featue. } else if(requires_config && default_config == ' ' ) { The user must change {{default_config}} to enable this feature. }", // TODO
    "legend": "User must explicitly enable this feature."
  },
  "disabled": {
    "name": "Disabled",
    "desc": " if(support.requires_config && support.default_config) { The user must change {{default_config}} to {{requires_config}} to enable this featue. } else if(requires_config && default_config == ' ' ) { The user must change {{default_config}} to enable this feature. }", // TODO
    "legend":
  }
*/

const webBrowsers = [ "webview_android", "chrome", "chrome_android", "edge", "edge_mobile", "firefox", "firefox_android", "ie", "ie_mobile", "opera", "opera_android", "safari", "safari_ios" ];
const webExtentionBrowsers =  [ "chrome", "edge", "firefox", "firefox_android", "opera" ];
const allBrowsers = [ "webview_android", "chrome", "chrome_android", "edge", "edge_mobile", "firefox", "firefox_android", "ie", "ie_mobile", "nodejs", "opera", "opera_android", "safari", "safari_ios", "servo" ];

var browsersArr = [];
var platformsArr = [];

function updateDefaults(theseBrowsers) {
  // make array of platforms based on platforms of browsers
  for (var browser of theseBrowsers) {
    let platformSlug = browsersLookup[browser].platform;
    if (platformsArr.indexOf(platformSlug) === -1){
      platformsArr.push(platformSlug);
    }
  }
  // sort platforms alphabetically
  platformsArr.sort();
  // make list of browsers sorted according to platform
  for (var platform of platformsArr) {
    for (var browserSlug of theseBrowsers) {
      if(browsersLookup[browserSlug].platform == platform) {
        browsersArr.push(browserSlug);
      }
    }
  }
}

// TODO: fallback to text if no icon in lookup?
// TODO: l10n
function writeIcon(iconSlug, lookup) {
  let iconName = lookup[iconSlug].name;
  let iconTitle;
  if (lookup[iconSlug].hasOwnProperty('desc')) {
    iconTitle = lookup[iconSlug].desc;
  } else {
    iconTitle = lookup[iconSlug].name;
  }
  output = '';
  output += `<abbr class="only-icon" title="${iconTitle}">`;
  output += `<span>${iconName}</span>`;
  output += `<i aria-hidden="true" class="ic-${iconSlug}"></i>`;
  output += `</abbr>`;
  return output;
}

function countBrowsersInplatform(platformSlug) {
  let count = 0;
  for (var browserSlug of browsersArr) {
    if (browsersLookup[browserSlug].platform === platformSlug) {
      count ++;
    }
  }
  return count;
}

function writeCompatCell(browserSlug, supportData) {
  let supportString = localize(compatStrings, 'supportsShort_unknown');
  let supportStatus = 'unknown';
  let supportIcons = '';
  // TODO: this is quite complicated
  // needs to take non-simple support into account
  if (supportData.hasOwnProperty(browserSlug) && supportData[browserSlug].hasOwnProperty('version_added')) {
    let versionInfo = supportData[browserSlug].version_added;
    switch (versionInfo) {
      case null:
        supportStatus = 'unknown';
        supportString = localize(compatStrings, 'supportsShort_unknown');
        break;
      case true:
        supportStatus = 'yes';
        supportString = localize(compatStrings, 'supportsShort_yes');
        break;
      case false:
        supportStatus = 'no';
        supportString = localize(compatStrings, 'supportsShort_no');
        break;
      default:
        supportStatus = 'yes';
        supportString = versionInfo;
    }
  }

  let output = `<td class="bc-supports-${supportStatus} bc-browser-${browserSlug}">`;
  output += supportString;
  output += supportIcons;
  output += `</td>`;
  return output;
}

// TODO: need status data for featureName
function getFeatureName(featureSlug, feature, singleFeature=false) {
  let featureName = '';
  let featureIcons = '';
  let experimentalIcon = '';
  let obsoleteIcon = '';

  // display name
  if(singleFeature && featureSlug === 'basic_support') {
    featureName = localize(compatStrings, 'feature_basicsupport');
  } else if (feature.hasOwnProperty('desc')) {
    featureName = feature.desc;
  } else {
    featureName = `<code>${featureSlug}</code>`
  }

  // support icons
  if(feature.hasOwnProperty('status')) {
    if (feature.status.experimental === true) {
      experimentalIcon = writeIcon('experimental', iconsLookup);
    }
    if (feature.status.obsolete === true) {
      obsoleteIcon =  writeIcon('obsolete', iconsLookup);
    }

    if(experimentalIcon || obsoleteIcon) {
      featureIcons += `<div class="bc-icons">`;
      featureIcons += experimentalIcon;
      featureIcons += obsoleteIcon;
      featureIcons += `</div>`;
    }
  }

  return featureName + featureIcons;
}

function writeCompatRow(featureName, supportData) {
  let output = `<tr>`;
  output += `<th scope="row">${featureName}</th>`;
  for (var browserSlug of browsersArr) {
    // TODO: need to add bc-platform-border to first cell in new platforms
    output += writeCompatCell(browserSlug, supportData);
  }
  output += `</tr>`;
  return output;
}

function writeCompatBody(data) {
  let output = `<tbody>`;

  // single feature
  if (data.hasOwnProperty('__compat')) {
      output += writeCompatRow(data['__compat']['description'], data['__compat']['support']);
  }
  /* else {
    // multiple features
    // TODO what if they have subfeatures?
    // maybe use recursive function? Could that handle both single and multiple?
    for (let featureSlug of Object.keys(data).sort()) {
      var feature = data[featureSlug];
      let featureName = getFeatureName(featureSlug, feature);
      let featureSupport = feature['__compat']['basic_support']['support'];
      output += writeCompatRow(featureName, featureSupport);
    }

  }
  */
  output += `</tbody>`;
  return output;
}

function writeCompatplatformsRow() {
  let output = `<tr class="bc-platforms">`;
  output += `<td></td>`;

  for (var platformSlug of platformsArr) {
    var thisplatformCount = countBrowsersInplatform(platformSlug);
    output += `<th colspan="${thisplatformCount}" class="bc-platform-${platformSlug}">`;
    output += writeIcon(platformSlug, platformsLookup);
    output += `</th>`;
  }

  output += `</tr>`;
  return output;
}

function writeCompatBrowsersRow() {
  let output = `<tr>`;
  output += `<td></td>`;
  for (var browserSlug of browsersArr) {
    output += `<th class="bc-browser-${browserSlug}">`;
    output += writeIcon(browserSlug, browsersLookup);
    output += `</th>`;
  }
  output += `</tr>`;
  return output;
}

function writeCompatHead() {
  let output = `<thead>`;
  output += writeCompatplatformsRow();
  output += writeCompatBrowsersRow();
  output += `</thead>`;
  return output;
}

// TODO: figure out how to pass browsers into function.
function writeCompatTable(data) {
  let output = `<div class="bc-data hidden">`;
  output += `<table class="bc-table bc-table-${browsersArr.length}">`;
  output += writeCompatHead();
  output += writeCompatBody(data);
  output += `</table>`;
  output += `</div>`;
  return output;
}


/*
  BOTH
*/

/*
Get compat data using a query string like "webextensions.api.alarms"
*/
function getData(queryString, obj) {
  return queryString.split('.').reduce(function(prev, curr) {
    return prev ? prev[curr] : undefined
  }, obj);
}

/*
Get features that should be displayed according to the query and the depth setting
Flatten them into a features array
*/
function traverseFeatures(obj, depth, identifier) {
  depth--;
  if (depth >= 0) {
    for (let i in obj) {
      if (!!obj[i] && typeof(obj[i])=="object" && i !== '__compat') {
        if (obj[i].__compat) {

          let featureNames = Object.keys(obj[i]);
          if (featureNames.length > 1) {
            // there are sub features below this node,
            // so we need to identify partial support for the main feature
            for (let subfeatureName of featureNames) {
              // if this is actually a subfeature (i.e. it is not a __compat object)
              // and the subfeature has a __compat object
              if ((subfeatureName !== '__compat') && (obj[i][subfeatureName].__compat)) {
                let browserNames = Object.keys(obj[i].__compat.support);
                for (let browser of browserNames) {
                  if (obj[i].__compat.support[browser].version_added !=
                      obj[i][subfeatureName].__compat.support[browser].version_added ||
                      obj[i][subfeatureName].__compat.support[browser].notes) {
                    obj[i].__compat.support[browser].partial_support = true;
                  }
                }
              }
            }
          }

          features.push({[identifier + i]: obj[i].__compat});
        }
        traverseFeatures(obj[i], depth, i + '.');
      }
    }
  }
}

var compatData = getData(query, bcd);
var features = [];
var identifier = query.split(".").pop();
var isWebExtensions = query.split(".")[0] === "webextensions";

if (!compatData) {
  output = s_no_data_found;
} else if (compatData.__compat) {
  // get optional main feature, add it to the feature list
  // call it "Basic support" if not aggregating
  if (!aggregateMode) {
    compatData.__compat.description = localize(compatStrings, 'feature_basicsupport');
  }
  features.push({[identifier]: compatData.__compat});
}

traverseFeatures(compatData, depth, '');

if (features.length > 0) {
  if (isWebExtensions) {
    output += writeTable('webextensions');
    if (!aggregateMode) { output += writeNotes(); }
  } else {
    output = `<div class="bc-old"><div class="htab">
    <a id="AutoCompatibilityTable" name="AutoCompatibilityTable"></a>
    <ul>
    <li class="selected">
    <a href="javascript:;">Desktop</a>
    </li>
    <li>
    <a href="javascript:;">Mobile</a>
    </li>
    </ul>
    </div>`;
    output += writeTable('desktop');
    output += writeTable('mobile');
    if (!aggregateMode) { output += writeNotes(); }
    output += `</div>`;
  }

  if (!aggregateMode) {
    if (isWebExtensions) {
      updateDefaults(webExtentionBrowsers);
    } else {
      updateDefaults(webBrowsers);
    }
    output += writeCompatTable(compatData);
  }


} else {
  output = s_no_data_found;
}
%>
<%-output%>
